# ============================================================
# personal-mcp — config.yaml
# ============================================================

# ── Server ──────────────────────────────────────────────────
server:
  host: 0.0.0.0
  port: 8000
  admin_token: "change-me-please"   # or set ADMIN_TOKEN env var
  base_url: http://localhost:8000


# ── Storage ─────────────────────────────────────────────────
db_path: db/profile.db
cache_dir: .cache
cache_ttl_hours: 6
watch_interval_minutes: 120

# Auto-export entities to YAML after ingestion (for manual editing workflow)
# If true, creates data/<source>_export.yaml files with entity_id
# You can then edit these files and update DB with: python ingest.py --yaml-update --file data/<source>_export.yaml
auto_export_yaml: true

# ── Session Tracking & Coverage Monitoring ─────────────────
# Tracks API client sessions to help LLM agents explore systematically
#
# Features:
#   - Anonymized logging (IP last octet removed)
#   - Unique visitor ID: hash(anonymized_ip + user_agent)
#   - SQLite persistence for sessions across restarts
#   - Coverage tracking with pagination awareness
#   - GET /coverage endpoint shows missing endpoints
#
# Pagination Logic:
#   - Non-paginated endpoints: 100% on first visit
#   - Paginated endpoints:
#     * 1 page visited → 50% coverage
#     * 2 pages visited → 75% coverage
#     * 3+ pages visited → 100% coverage
#
# Session Reset:
#   - Visiting root endpoint (/) resets session
#   - Sessions auto-expire after timeout_hours
#
# Response Headers (on every request):
#   X-Coverage-Percentage: 30.0
#   X-Coverage-Visited: 3
#   X-Coverage-Total: 10
#   X-Session-Request-Count: 5
#
session:
  enabled: true
  timeout_hours: 5              # Session expiry (hours)
  log_file: logs/api_access.log # File logging path
  track_coverage: true          # Enable coverage tracking
  db_path: db/sessions.db       # SQLite database path
  
  # Relevant endpoints for coverage tracking (endpoints with metrics)
  # Format: endpoint_pattern: {paginated: true|false}
  # Each endpoint counts equally (1 point)
  # Paginated endpoints need multiple pages for 100% coverage
  relevant_endpoints:
    /greeting: {paginated: false}        # Personal identity
    /stages: {paginated: true}           # Career timeline list
    /stages/{id}: {paginated: false}     # Single stage detail
    /oeuvre: {paginated: true}           # Projects/articles list
    /oeuvre/{id}: {paginated: false}     # Single project detail
    /skills: {paginated: true}           # All skills with metrics
    /skills/{name}: {paginated: false}   # Skill detail
    /technology: {paginated: true}       # All technologies with metrics
    /technology/{name}: {paginated: false} # Technology detail
    /tags/{tag_name}: {paginated: false}   # Tag detail with metrics

# ── Your identity ────────────────────────────────────────────
# fixed values, will be added to the generic endpoint
# supports multi languages, e.g. identity.de.name → "name": "Nicky Reinert" in the German version of the profile
# dynamic attributes, every sub attribute will appear in the JSON output of the generic endpoint, e.g. identity.name → "name": "Nicky Reinert"
identity:
  de:
    name: Nicky Reinert
    tagline: "Understand Data → Connect Interfaces → Automate Processes → Solve Problems"
    location: Berlin, Germany
    github_url: https://github.com/nickyreinert
    medium_url: https://nickyreinert.medium.com
    blog_url: https://nickyreinert.de
    linkedin_url: https://www.linkedin.com/in/nickyreinert
    description: "Persönliches Profil von Nicky Reinert, das berufliche Erfahrungen, Projekte und Veröffentlichungen zeigt."
  en:
    name: Nicky Reinert
    tagline: "Understand Data → Connect Interfaces → Automate Processes → Solve Problems"
    location: Berlin, Germany
    github_url: https://github.com/nickyreinert
    medium_url: https://nickyreinert.medium.com
    blog_url: https://nickyreinert.de
    linkedin_url: https://www.linkedin.com/in/nickyreinert
    description: "Personal profile of Nicky Reinert, showcasing professional experience, projects, and publications."

# ── LLM Enrichment ──────────────────────────────────────────
# backend: groq | ollama | none
#
# GROQ (recommended: fast, free tier, ~100 calls/day free):
#   pip install groq && export GROQ_API_KEY=gsk_...
#   models: llama3-8b-8192 (fast) | llama3-70b-8192 (smart) | mixtral-8x7b-32768
#
# Ollama (fully local, zero API cost, privacy-first):
#   brew install ollama && ollama serve && ollama pull llama3
#   models: llama3 | mistral | phi3 | gemma2 | qwen2
#
llm:
  backend: ollama
  model: mistral-small:24b-instruct-2501-q4_K_M
  groq_api_key: ""          # or set GROQ_API_KEY env var
  ollama_url: http://localhost:11434

# ── Statoc export ──────────────────────────────────────────
# Fallback yaml in case the MCP server is not response, according to groundinpage rules https://groundingpage.com
# TOOD: whats the best name here?
static: llm.yaml


# ── Stages (WHERE you worked/studied) ──────────────────────────
# Stages are companies, institutions, professional roles, education, certifications
#
# Workflow:
#   1. First run: Parses PDF using LLM → creates linkedin_profile.pdf.yaml cache
#   2. Manual editing: Edit linkedin_profile.pdf.yaml to refine content
#   3. Subsequent runs: Loads from .yaml cache (fast, no LLM needed)
#   4. Disable: Set enabled=false to skip stages processing entirely
#
# source_path: Path to LinkedIn profile PDF export
#   - If <source_path>.yaml exists → loads from YAML (user-edited cache)
#   - If <source_path>.yaml missing → parses PDF with LLM and saves YAML
#
stages:
  enabled: true                      # Set false to skip stages processing
  connector: linkedin_pdf            # LinkedIn PDF connector with auto-caching to YAML
  url: file://data/linkedin_profile.pdf  # LinkedIn export PDF file (relative to project root)
  llm-processing: true

# ── Sources for oeuvre ─────────────────────────────────────────────────
# Configure the sources to fetch your data from. Each source can be enabled/disabled independently.
# source names must be unique, e.g. github, medium, blog_1, blog_2, etc. but you can define as many as you like.
oeuvre:

  github:
    enabled: true
    connector: github_api
    url: https://api.github.com/users/nickyreinert/repos
    sub_type_override: coding   # Override default sub_type (coding/blog_post/article/book/website/podcast/video)
    limit: 0                    # 0 = all, otherwise integer limit on number of repos to fetch
    llm-processing: true
    fetch_readmes: true         # true = richer descriptions, slower

  medium_init:
     # for initial fetch of your articles, go to the list fo alll your stories and copy the whole dome into an html file
    enabled: false
    connector: medium_raw
    url: file://data/Medium.html  # Public RSS feed
    

  medium:
    enabled: true
    connector: manual
    url: https://nickyreinert.medium.com/  # Profile page - shows all articles
    sub_type_override: article
    limit: 0  # 0 = all articles found
    cache_ttl_hours: 168  # 7 days
    llm-processing: true

    connector-setup:
      # Select all article links on profile page
      # Medium uses various link formats, try broad selector then filter
      post_url_selector: 'a[href*="medium.com/@nickyreinert"]'
      # When visiting each article:
      post-title-selector: 'h1'
      post-content-selector: 'article'
      post-published-date-selector: 'meta[property="article:published_time"]'
      post-description-selector: 'meta[property="og:description"]'   

  blog_1:
    enabled: true
    connector: rss
    url: https://nickyreinert.de/index.xml
    sub_type_override: blog_post  # Override default sub_type
    llm-processing: true
    limit: 0                    # 0 = all, otherwise integer limit on number of posts to fetch

  # Example: Sitemap connector
  # Mode 1: Multi-entity (each page = separate entity)
  # blog_sitemap_pages:
  #   enabled: false
  #   connector: sitemap
  #   url: https://example.com/sitemap.xml
  #   sub_type_override: blog_post
  #   limit: 20                  # Process only first 20 URLs from sitemap
  #   cache_ttl_hours: 336       # 14 days cache TTL
  #   llm-processing: true
  #   single-entity: false       # Each page becomes a separate entity (default)
  #   cache-file: file://data/blog_sitemap.yaml  # Optional: cache for manual editing
  #
  #   connector-setup:
  #     post-title-selector: h1
  #     post-content-selector: article
  #     post-published-date-selector: 'time[datetime]'
  #     post-description-selector: 'meta[name="description"]'
  
  # Mode 2: Single-entity (whole site = one entity)
  # project_website:
  #   enabled: false
  #   connector: sitemap
  #   url: https://example.com/sitemap.xml
  #   sub_type_override: website
  #   llm-processing: true
  #   single-entity: true        # Treat entire site as one entity
  #   cache-file: file://data/project_sitemap.yaml  # Optional: cache for manual editing
  #
  #   connector-setup:
  #     post-title-selector: h1
  #     post-content-selector: main
  #     post-description-selector: 'meta[name="description"]'

# ── Internationalization (i18n) ──────────────────────────────────────────────
# target_languages: languages to translate into (besides the default 'en').
# Run: python -m llm.translator   or   POST /admin/translate
#
# batch_sleep_seconds: pause between LLM calls (GROQ free tier: ~30 req/min)
# A full German translation of ~200 entities takes roughly 3-5 minutes.
#
i18n:
  # while you can add as many languages to the identity area on top, if you want the dynamic part to be 
  # translated automatically, you must add the language code here, e.g. "de" for German, "en" for English, "fr" for French, etc.
  # the LLM will take over the translation part then
  target_languages:
    - de                          # German — primary second language
    - en                          # English — primary second language
  batch_sleep_seconds: 0.4        # ~25 req/min → safe under GROQ free tier

# ── Tag Metrics Configuration ──────────────────────────────────────────────
# Customizable formulas and weights for calculating skill/technology/tag metrics
# All weights are normalized internally, so total doesn't need to equal 1.0 or 100

metrics:
  enabled: true
  version: "1.1"  # increment when changing formulas to trigger recalculation

  # Context weights: differentiate "wrote about it" vs "worked with it"
  # Applied as multiplier to proficiency scores based on entity context
  context_weights:
    default_weight: 0.5     # Fallback weight for uncategorized entities
    stages:
      job: 1.0              # Actual work experience (full weight)
      education: 0.85       # Formal learning (strong weight)
      achievement: 0.7      # Certification/achievement (good weight)
      other: 0.8
    oeuvre:
      coding: 1.0           # Built something with it (full weight)
      talk: 0.6             # Presented on it (medium weight)
      article: 0.3          # Wrote article about it (low weight)
      blog_post: 0.3        # Wrote blog post about it (low weight)
      book: 0.7             # Wrote book about it (good weight)
      podcast: 0.5          # Discussed it (medium-low weight)
      video: 0.5            # Made video about it (medium-low weight)
      website: 0.6          # Website project (medium weight)
      other: 0.5

  # Proficiency: measures expertise level (0-100) based on recency and duration
  proficiency:
    recency_weight: 0.6
    duration_weight: 0.4
    recency_decay_halflife: 3.0
    min_score: 5.0

  # Experience years: total time spent (weighted by intensity)
  experience_years:
    deduplicate_overlaps: true
    current_bonus_multiplier: 1.2

  # Frequency: how often tag appears relative to all entities
  frequency:
    min_threshold: 3

  # Diversity: variety of contexts (flavors, categories)
  diversity:
    flavor_weight: 0.5
    category_weight: 0.5
    saturation_threshold: 10

  # Growth trend: usage pattern over time
  growth:
    min_timespan_years: 1.0
    min_entity_count: 3
    increasing_threshold: 0.5
    decreasing_threshold: -0.3

  # Relevance: composite score combining all metrics (0-100)
  relevance:
    weights:
      proficiency: 0.30
      frequency: 0.20
      recency: 0.20
      diversity: 0.15
      experience: 0.10
      growth: 0.05
    current_bonus: 10
    stale_penalty: 15
    stale_threshold_years: 5
